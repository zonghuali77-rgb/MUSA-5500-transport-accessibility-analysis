<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Singapore – Global Bus Accessibility Analysis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-1d4f84655f446305ac42a8f1abcf7405.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Global Bus Accessibility Analysis</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../website/about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Project Overview</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../website/methods.html"> 
<span class="menu-text">Methods</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../website/results.html"> 
<span class="menu-text">Results</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-cities" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Cities</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-cities">    
        <li>
    <a class="dropdown-item" href="../website/city_nyc.html">
 <span class="dropdown-text">New York City</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../website/city_sg.html">
 <span class="dropdown-text">Singapore</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../website/city_ams.html">
 <span class="dropdown-text">Amsterdam</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../website/city_sh.html">
 <span class="dropdown-text">Shanghai</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../website/data_sources.html"> 
<span class="menu-text">Data Sources</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Singapore</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="bus-stops-and-boundary" class="level1">
<h1>1. Bus stops and boundary</h1>
<p><img src="../figures/sg_bus_stops.png" class="img-fluid"></p>
<p>Singapore’s bus stops are tightly concentrated within the main urbanised island. The stop pattern broadly follows the public housing new towns from Jurong in the west to Tampines and Pasir Ris in the east, with particularly dense strings of stops along the north–south and east–west corridors that parallel the MRT lines.<br>
Large gaps in the north-west and central part of the island coincide with the Central Catchment Nature Reserve, military training areas and low-density industrial land, rather than underserved residential neighbourhoods.</p>
<p>Compared with New York City, Singapore has fewer extreme peripheral areas: almost all developable land is within a continuous urban fabric. This helps explain why Singapore records the highest bus-stop density in the comparative statistics (about <strong>6.6 stops/km²</strong>), considerably higher than New York City (~2.5 stops/km²) and somewhat higher than Amsterdam (~4.7 stops/km²). The morphology of a compact island city-state with strong planning control supports a finely spaced stop network.</p>
<hr>
</section>
<section id="m-coverage" class="level1">
<h1>2. 500 m coverage</h1>
<p><img src="../figures/sg_coverage_500m.png" class="img-fluid"></p>
<p>The 500 m buffer map shows that most urbanised parts of Singapore fall within walking distance of at least one bus stop. The estimated share of land area covered within 500 m is about <strong>55.9%</strong>, very similar to the other three cities (roughly 55–57%). However, because large tracts of land are reserved for nature, industry or airport uses, the coverage percentage is not directly comparable to residential accessibility.</p>
<p>Spatially, high coverage is seen:</p>
<ul>
<li>along the north-south corridor from Woodlands through Yishun and Ang Mo Kio to Toa Payoh;</li>
<li>across the eastern “HDB heartlands” such as Bedok, Tampines and Pasir Ris;<br>
</li>
<li>in older public housing estates and industrial areas in the west (Jurong East/West).</li>
</ul>
<p>Lower coverage appears in the central water-catchment and military zones, as well as in some coastal industrial areas. These are intentional “holes” in the network rather than service gaps.</p>
<p>Relative to New York City, where coverage drops in low-density fringes and on barrier islands, Singapore’s coverage map is more contiguous across the urbanised band. This reflects the state’s planning goal of ensuring that almost all public housing estates are within a short walk of both bus services and the MRT.</p>
<hr>
</section>
<section id="kernel-density-heatmap" class="level1">
<h1>3. Kernel density heatmap</h1>
<p><img src="../figures/sg_kde_bw300.png" class="img-fluid"></p>
<p>The kernel density heatmap reveals several high-intensity ridges of bus stop concentration:</p>
<ul>
<li>a strong east–west band from Jurong East through Clementi and Queenstown towards the Central Area;</li>
<li>a dense cluster in and around the traditional CBD and Orchard corridor;</li>
<li>high densities in new towns such as Ang Mo Kio, Hougang, Bedok, Tampines and Pasir Ris.</li>
</ul>
<p>Compared with the point map, the KDE surface smooths local variation and highlights broader structural patterns: Singapore’s bus system concentrates stops along town centres, interchanges and major distributor roads, with somewhat lower intensities in industrial estates and exclusive residential enclaves.</p>
<p>When contrasted with New York City’s KDE, Singapore appears more spatially even: rather than a single dominant spine like Manhattan, multiple “peaks” related to decentralised new-town centres can be seen. This is consistent with the transit-oriented land-use strategy in which each new town has its own bus interchange and commercial core, reducing the need to funnel all trips through a single CBD.</p>
<hr>
</section>
<section id="nearest-neighbour-distances" class="level1">
<h1>4. Nearest-neighbour distances</h1>
<p><img src="../figures/sg_nearest_neighbor.png" class="img-fluid"></p>
<p>The nearest-neighbour analysis quantifies how tightly bus stops are spaced:</p>
<ul>
<li>mean nearest-neighbour distance: <strong>~79.7 m</strong><br>
</li>
<li>median distance: <strong>~57.1 m</strong><br>
</li>
<li>90th percentile distance: <strong>~161 m</strong><br>
</li>
<li>minimum distance: essentially <strong>0 m</strong> (paired stops or loop terminals)<br>
</li>
<li>maximum distance: <strong>~1.1 km</strong></li>
</ul>
<p>The histogram is sharply right-skewed: the majority of stops lie within 100 m of their closest neighbour, indicating a very fine mesh of services along key corridors. The spatial map shows slightly larger distances in industrial areas, expressway segments and some coastal reclamation zones, where stops are naturally more widely spaced and pedestrian access is restricted.</p>
<p>Compared with the other cities, Singapore shows:</p>
<ul>
<li><strong>much smaller mean and median distances than New York City</strong> (mean ≈ 183 m, median ≈ 108 m), reflecting closer stop spacing in a compact urban environment;</li>
<li><strong>slightly larger distances than Amsterdam</strong>, where the highly walkable inner city and tram-bus integration bring typical distances down to around 63 m mean and 39 m median;</li>
<li><strong>shorter distances than Shanghai</strong>, where the large metropolitan extent and arterial focus of services yield a mean ≈ 91 m and a maximum above 1.2 km.</li>
</ul>
<p>Overall, the nearest-neighbour statistics support the interpretation that Singapore’s bus network provides very fine local accessibility within built-up areas, with only a small share of stops experiencing gaps greater than 200–300 m.</p>
<hr>
</section>
<section id="context-structure-of-the-singapore-bus-network" class="level1">
<h1>5. Context: structure of the Singapore bus network</h1>
<p><img src="../image/Singapore_Lines.png" class="img-fluid" style="width:80.0%"></p>
<p><em>Image source: Land Transport Authority, Singapore – Bus Route Map.</em></p>
<p>The official route map helps to interpret the spatial metrics above:</p>
<ul>
<li><strong>Trunk and express routes</strong> form long east–west and north–south axes, broadly mirrored in the KDE heatmap’s high-density bands.</li>
<li><strong>Feeder services</strong> circulate within each new town, connecting housing blocks to bus interchanges and MRT stations; these explain the dense local clusters of stops and the short nearest-neighbour distances.</li>
<li>Under the <strong>Bus Contracting Model</strong>, routes are bundled into service packages and competitively tendered, but still centrally planned by the Land Transport Authority. This allows the authority to maintain relatively even geographic coverage and regular stop spacing, independent of purely commercial considerations.</li>
</ul>
<p>Placed alongside New York City, Amsterdam and Shanghai, Singapore’s figures illustrate a particular model of high-intensity bus provision in a small, centrally governed city-state:</p>
<ul>
<li>stop density is the highest among the four cases, consistent with the emphasis on public transport as the dominant travel mode;</li>
<li>500 m coverage is similar to the others, but this is achieved while a large share of land is reserved for non-urban uses, implying especially good coverage of <em>developed</em> land;</li>
<li>nearest-neighbour distances are short but not extreme, suggesting a balance between walking convenience and operational efficiency.</li>
</ul>
<p>These patterns reflect policy choices: a strong integration between bus and rail, systematic provision for HDB estates, and careful control of urban expansion. Together they help explain why Singapore’s bus system achieves both high spatial accessibility and relatively compact urban form.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>